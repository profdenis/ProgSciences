{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Cours de programmation en sciences \u00b6 Auteur : Denis Rinfret Ressources \u00b6 Logiciels \u00b6 Note : Page r\u00e9dig\u00e9e en partie avec l\u2019aide d\u2019un assistant IA, principalement \u00e0 l\u2019aide de Perplexity AI, avec les LLM GPT-4 Omni et Claude 3.5 Sonnet . L\u2019IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et/ou des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l\u2019auteur.","title":"Cours de programmation en sciences"},{"location":"#cours-de-programmation-en-sciences","text":"Auteur : Denis Rinfret","title":"Cours de programmation en sciences"},{"location":"#ressources","text":"","title":"Ressources"},{"location":"#logiciels","text":"Note : Page r\u00e9dig\u00e9e en partie avec l\u2019aide d\u2019un assistant IA, principalement \u00e0 l\u2019aide de Perplexity AI, avec les LLM GPT-4 Omni et Claude 3.5 Sonnet . L\u2019IA a \u00e9t\u00e9 utilis\u00e9e pour g\u00e9n\u00e9rer des explications, des exemples et/ou des suggestions de structure. Toutes les informations ont \u00e9t\u00e9 v\u00e9rifi\u00e9es, \u00e9dit\u00e9es et compl\u00e9t\u00e9es par l\u2019auteur.","title":"Logiciels"},{"location":"Algorithmes/01_Premiers_Algorithmes/","text":"Introduction aux algorithmes \u00b6 Algorithmes : D\u00e9finitions \u00b6 Commen\u00e7ons par quelques d\u00e9finitions du mot algorithme : Cambridge Dictionary une liste d\u2019instructions pour r\u00e9soudre un probl\u00e8me un ensemble d\u2019instructions ou de r\u00e8gles math\u00e9matiques qui, habituellement donn\u00e9es \u00e0 un ordinateur, aideront \u00e0 calculer une r\u00e9ponse \u00e0 un probl\u00e8me Merriam-Webster une proc\u00e9dure pour r\u00e9soudre un probl\u00e8me math\u00e9matique (comme celui de trouver le plus grand diviseur commun) en un nombre fini d\u2019\u00e9tapes qui implique souvent la r\u00e9p\u00e9tition d\u2019une op\u00e9ration plus g\u00e9n\u00e9ralement : une proc\u00e9dure \u00e9tape par \u00e9tape pour r\u00e9soudre un probl\u00e8me ou accomplir une certaine fin Geeks for Geeks Un ensemble fini de r\u00e8gles ou d\u2019instructions \u00e0 suivre dans les calculs ou d\u2019autres op\u00e9rations pour r\u00e9soudre des probl\u00e8mes Une proc\u00e9dure pour r\u00e9soudre un probl\u00e8me math\u00e9matique en un nombre fini d\u2019\u00e9tapes qui implique souvent des op\u00e9rations r\u00e9cursives Autres d\u00e9finitions possibles : Un algorithme est une proc\u00e9dure bien d\u00e9finie qui permet \u00e0 un ordinateur de r\u00e9soudre un probl\u00e8me. Une autre fa\u00e7on de d\u00e9crire un algorithme est de dire qu\u2019il s\u2019agit d\u2019une approche \u00e9tape par \u00e9tape pour r\u00e9soudre un probl\u00e8me ou accomplir une t\u00e2che. En informatique et en math\u00e9matiques, un algorithme est une s\u00e9quence d\u2019instructions dont le principal objectif est de r\u00e9soudre un probl\u00e8me sp\u00e9cifique, d\u2019effectuer une certaine action ou de calculer. Dans certains cas, les algorithmes sont utilis\u00e9s pour le traitement des donn\u00e9es et les t\u00e2ches de raisonnement automatis\u00e9. Un algorithme est un ensemble sp\u00e9cifique d\u2019instructions con\u00e7ues pour effectuer une t\u00e2che particuli\u00e8re. Cela peut \u00eatre un processus simple, comme la multiplication de deux nombres, ou une op\u00e9ration complexe, comme la lecture d\u2019un fichier vid\u00e9o compress\u00e9. Les moteurs de recherche utilisent des algorithmes complexes pour trier les pages Web pertinentes parmi des millions de r\u00e9sultats. Un algorithme en informatique est une proc\u00e9dure bien d\u00e9finie qui prend certaines valeurs en entr\u00e9e et les traite pour produire une certaine valeur en sortie. Les algorithmes sont essentiels pour l\u2019ex\u00e9cution de proc\u00e9dures \u00e9tape par \u00e9tape pour les calculs et le traitement des donn\u00e9es. Un algorithme est une s\u00e9quence de comportement \u00e9tape par \u00e9tape qui d\u00e9finit un ensemble de calculs. Ils sont utilis\u00e9s pour le calcul, le traitement des donn\u00e9es, le raisonnement automatis\u00e9 et d\u2019autres t\u00e2ches. Veuillez noter qu\u2019un algorithme doit \u00eatre clair et sans ambigu\u00eft\u00e9, il doit avoir des entr\u00e9es et des sorties bien d\u00e9finies, et il doit \u00eatre fini. Lors de la conception d\u2019un algorithme, il y aura g\u00e9n\u00e9ralement des entr\u00e9es donn\u00e9es \u00e0 l\u2019algorithme. Ensuite, apr\u00e8s avoir effectu\u00e9 des calculs en utilisant ces entr\u00e9es, les r\u00e9sultats seront \u00e9mis ou renvoy\u00e9s \u00e0 un utilisateur, ou \u00e0 un autre algorithme qui utilisera ces r\u00e9sultats pour effectuer ses propres calculs \u00e0 \u00eatre sortis ou renvoy\u00e9s. En d\u2019autres termes, les algorithmes pourraient \u00eatre cha\u00een\u00e9s les uns \u00e0 la suite des autres. Notation sous forme de diagrammes \u00b6 Pour repr\u00e9senter les algorithmes graphiquement, nous allons utiliser diagrammes d\u2019\u00e9tats UML , en utilisant la notation disponible dans le logiciel PlantUML . Pour repr\u00e9senter les algorithmes de mani\u00e8re graphique, nous utiliserons les Diagrammes d\u2019Activit\u00e9 , et nous utiliserons PlantUML pour les dessiner. Nous repr\u00e9senterons \u00e9galement les algorithmes en pseudocode, dans une notation similaire \u00e0 celle du langage de programmation Python. Plus tard, apr\u00e8s avoir discut\u00e9 des types de donn\u00e9es et de certains autres sujets, nous \u00e9crirons directement les algorithmes dans le langage de programmation Python. Le diagramme suivant montre la notation pour les diagrammes d\u2019activit\u00e9 les plus basiques. Code PlantUML @startuml skinparam defaultFontSize 16 start note right noeud de d\u00e9part end note :some action; note right action simple : lire une valeur, faire un calcul, ... end note :some other action; stop note right noeud de fin end note @enduml Exemples \u00b6 Calcul de l\u2019aire d\u2019un rectangle \u00b6 Commen\u00e7ons par un exemple simple : comment calculons-nous l\u2019aire d\u2019un rectangle ? Nous avons besoin de 2 valeurs pour calculer l\u2019aire d\u2019un rectangle : sa largeur et sa hauteur . Nous supposons pour l\u2019instant que ces 2 valeurs seront entr\u00e9es dans le programme par un utilisateur, \u00e0 l\u2019aide d\u2019un dispositif d\u2019entr\u00e9e (probablement un clavier), et que les r\u00e9sultats seront affich\u00e9s \u00e0 l\u2019utilisateur \u00e0 l\u2019aide d\u2019un dispositif de sortie (probablement un \u00e9cran). Nous verrons plus tard que les entr\u00e9es et les sorties peuvent ne pas \u00eatre prises ou donn\u00e9es directement par/aux utilisateurs, mais pourraient plut\u00f4t \u00eatre donn\u00e9es \u00e0 une fonction en tant que param\u00e8tres, ou renvoy\u00e9es par une fonction. Entr\u00e9es : la largeur et la hauteur du rectangle Sortie : l\u2019 aire du rectangle Diagramme \u00b6 Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer largeur; :entrer hauteur; :aire = largeur * hauteur; :afficher aire; stop @enduml Pseudocode \u00b6 largeur = entrer() hauteur = entrer() aire = largeur * hauteur afficher(aire) Discussion \u00b6 Certaines actions concernent le calcul de certaines valeurs bas\u00e9es sur d\u2019autres valeurs, comme aire = largeur * hauteur . Notez que nous utilisons * comme symbole de multiplication. Dans ce cas, le calcul largeur * hauteur est \u00e9crit \u00e0 droite du signe \u00e9gal ( = ), et le r\u00e9sultat est conserv\u00e9 dans aire , qui sera affich\u00e9 dans l\u2019\u00e9tape suivante. Dans cet exemple, il y a 3 variables : largeur , hauteur et aire . Ces variables sont utilis\u00e9es pour repr\u00e9senter ou retenir certaines valeurs qui seront entr\u00e9es ou calcul\u00e9es, et qui seront r\u00e9utilis\u00e9es plus tard dans les calculs ou envoy\u00e9es en sortie. Les diagrammes d\u2019activit\u00e9 sont de haut niveau , ce qui signifie qu\u2019ils sont souvent un peu simplifi\u00e9s, ils n\u2019entrent pas dans chaque petit d\u00e9tail. Nous ne nous emb\u00eatons pas \u00e0 d\u00e9finir chaque variable formellement, donc lorsque nous \u00e9crivons entrer largeur , il est sous-entendu qu\u2019une variable nomm\u00e9e largeur sera d\u00e9finie, et sa valeur sera ce qui a \u00e9t\u00e9 entr\u00e9. De m\u00eame, pour afficher aire , nous disons simplement que nous voulons que aire soit affich\u00e9e en sortie, mais nous ne nous emb\u00eatons pas avec les d\u00e9tails d\u2019o\u00f9 et comment aire sera affich\u00e9e. Nous serons un peu plus pr\u00e9cis dans le pseudocode, et beaucoup plus pr\u00e9cis lorsque nous \u00e9crirons un programme pour faire les calculs pour de vrai. \u00c0 ce stade, les diagrammes sont utilis\u00e9s pour avoir une id\u00e9e de ce qui doit \u00eatre fait. Ils deviendront plus compliqu\u00e9s quand nous rencontrerons des algorithmes plus complexes. Avec un peu d\u2019exp\u00e9rience, nous serons en mesure d\u2019\u00e9crire du code directement sans cr\u00e9er d\u2019abord des diagrammes d\u2019activit\u00e9 ou \u00e9crire du pseudocode, mais m\u00eame avec de l\u2019exp\u00e9rience, lorsque nous rencontrons des probl\u00e8mes plus complexes, les diagrammes aident souvent. De nombreux types de diagrammes seront utilis\u00e9s lors de la conception et du d\u00e9veloppement de syst\u00e8mes logiciels, tels que les diagrammes de s\u00e9quences , de cas d\u2019utilisation , d\u2019 \u00e9tats , de classes \u2026 Les entr\u00e9es et les sorties sont elles-m\u00eames des t\u00e2ches complexes, et d\u00e9pendront exactement de la fa\u00e7on dont nous voulons entrer et sortir (afficher) les valeurs. Nous r\u00e9sumons donc ces t\u00e2ches et nous disons simplement pour l\u2019instant que nous entrons et sortons des valeurs d\u2019une certaine mani\u00e8re. Dans le pseudocode, nous \u00e9crivons ces 2 t\u00e2ches un peu diff\u00e9remment par rapport aux diagrammes : nous utilisons la notation de fonction pour \u00eatre un peu plus pr\u00e9cis. La t\u00e2che d\u2019entrer d\u2019une valeur produit (ou donne ou retourne) une valeur, et nous stockons cette valeur dans une variable, comme dans largeur = entrer() . Nous utilisons les parenth\u00e8ses () pour signifier que nous appelons, ou ex\u00e9cutons, la fonction entrer . La valeur produite est stock\u00e9e dans la variable largeur . Nous disons aussi que la valeur renvoy\u00e9e par la fonction entrer est assign\u00e9e \u00e0 la variable largeur . Pour pouvoir accomplir sa t\u00e2che, la fonction afficher a besoin de savoir quelle valeur afficher, donc nous lui donnons une valeur entre les () lorsque nous l\u2019appelons. Dans notre exemple, nous lui avons donn\u00e9 la variable aire , alors elle affiche la valeur contenue dans la variable aire . afficher ne renvoie aucune valeur, c\u2019est pourquoi nous ne l\u2019assignons \u00e0 rien. Meilleures entr\u00e9es et sorties \u00b6 Un probl\u00e8me lors de l\u2019entr\u00e9e d\u2019une valeur dans l\u2019exemple pr\u00e9c\u00e9dent est que nous ne donnons aucune information \u00e0 l\u2019utilisateur sur ce qui doit \u00eatre entr\u00e9. Dans ce cas, l\u2019utilisateur devinera probablement que la largeur et la hauteur doivent \u00eatre entr\u00e9es pour pouvoir calculer l\u2019aire d\u2019un rectangle, mais laquelle doit \u00eatre entr\u00e9e en premier ? Dans ce cas, cela n\u2019a pas vraiment d\u2019importance, car nous obtiendrons les m\u00eames r\u00e9sultats, mais en g\u00e9n\u00e9ral, l\u2019inversion de 2 entr\u00e9es peut changer consid\u00e9rablement les r\u00e9sultats. Nous avons donc besoin de donner plus d\u2019informations \u00e0 l\u2019utilisateur. Voici 2 versions faisant la m\u00eame chose. Diagrammes \u00b6 Code PlantUML @startuml skinparam defaultFontSize 16 start :afficher \"Calcul de l'aire d'un rectangle\"; :afficher \"Entrez la largeur du rectangle :\"; :entrer largeur; :afficher \"Entrez la hauteur du rectangle :\"; :entrer hauteur; :aire = largeur * hauteur; :afficher \"l'aire est\"; :afficher aire; stop @enduml Code PlantUML @startuml skinparam defaultFontSize 16 start :afficher(\"Calcul de l'aire d'un rectangle\"); :largeur = entrer(\"Entrez la largeur du rectangle :\"); :hauteur = entrer(\"Entrez la hauteur du rectangle :\"); :aire = largeur * hauteur; :afficher(\"l'aire est\", aire); stop @enduml Discussion \u00b6 Le premier de ces deux diagrammes est correct, mais il serait g\u00e9n\u00e9ralement consid\u00e9r\u00e9 comme trop verbeux. Nous laisserons de c\u00f4t\u00e9 la sortie suppl\u00e9mentaire pour nous concentrer sur l\u2019algorithme lui-m\u00eame, ou nous utiliserons la deuxi\u00e8me version dans laquelle une nouvelle version de la fonction entrer est utilis\u00e9e directement dans les diagrammes. Cette version de la fonction entrer accepte une cha\u00eene de caract\u00e8res en param\u00e8tre, qui sera affich\u00e9e avant d\u2019attendre qu\u2019une valeur soit entr\u00e9e. Une cha\u00eene de caract\u00e8res, pour la distinguer d\u2019une ou de plusieurs variables, est donn\u00e9e entre guillemets doubles \"\" . La fonction afficher est \u00e9galement utilis\u00e9e diff\u00e9remment. On lui donne 2 choses \u00e0 afficher, une cha\u00eene et une variable contenant les r\u00e9sultats. Elle les affichera l\u2019une apr\u00e8s l\u2019autre. Nous aurons besoin de messages de sortie plus complets lors de l\u2019\u00e9criture du code, et nous les inclurons souvent lors de l\u2019\u00e9criture du pseudocode, mais pas lors de la cr\u00e9ation de diagrammes d\u2019activit\u00e9 pour les garder plus petits et nous aider \u00e0 nous concentrer sur l\u2019algorithme lui-m\u00eame, et non sur les d\u00e9tails des entr\u00e9es et des sorties, \u00e0 moins que l\u2019algorithme devait traiter les entr\u00e9es et les sorties d\u2019une mani\u00e8re tr\u00e8s sp\u00e9cifique. Pseudocode \u00b6 afficher(\"Calcul de l'aire d'un rectangle\") largeur = entrer(\"Entrez la largeur du rectangle :\") hauteur = entrer(\"Entrez la hauteur du rectangle :\") aire = largeur * hauteur afficher(\"l'aire est\", aire)","title":"Introduction aux algorithmes"},{"location":"Algorithmes/01_Premiers_Algorithmes/#introduction-aux-algorithmes","text":"","title":"Introduction aux algorithmes"},{"location":"Algorithmes/01_Premiers_Algorithmes/#algorithmes-definitions","text":"Commen\u00e7ons par quelques d\u00e9finitions du mot algorithme : Cambridge Dictionary une liste d\u2019instructions pour r\u00e9soudre un probl\u00e8me un ensemble d\u2019instructions ou de r\u00e8gles math\u00e9matiques qui, habituellement donn\u00e9es \u00e0 un ordinateur, aideront \u00e0 calculer une r\u00e9ponse \u00e0 un probl\u00e8me Merriam-Webster une proc\u00e9dure pour r\u00e9soudre un probl\u00e8me math\u00e9matique (comme celui de trouver le plus grand diviseur commun) en un nombre fini d\u2019\u00e9tapes qui implique souvent la r\u00e9p\u00e9tition d\u2019une op\u00e9ration plus g\u00e9n\u00e9ralement : une proc\u00e9dure \u00e9tape par \u00e9tape pour r\u00e9soudre un probl\u00e8me ou accomplir une certaine fin Geeks for Geeks Un ensemble fini de r\u00e8gles ou d\u2019instructions \u00e0 suivre dans les calculs ou d\u2019autres op\u00e9rations pour r\u00e9soudre des probl\u00e8mes Une proc\u00e9dure pour r\u00e9soudre un probl\u00e8me math\u00e9matique en un nombre fini d\u2019\u00e9tapes qui implique souvent des op\u00e9rations r\u00e9cursives Autres d\u00e9finitions possibles : Un algorithme est une proc\u00e9dure bien d\u00e9finie qui permet \u00e0 un ordinateur de r\u00e9soudre un probl\u00e8me. Une autre fa\u00e7on de d\u00e9crire un algorithme est de dire qu\u2019il s\u2019agit d\u2019une approche \u00e9tape par \u00e9tape pour r\u00e9soudre un probl\u00e8me ou accomplir une t\u00e2che. En informatique et en math\u00e9matiques, un algorithme est une s\u00e9quence d\u2019instructions dont le principal objectif est de r\u00e9soudre un probl\u00e8me sp\u00e9cifique, d\u2019effectuer une certaine action ou de calculer. Dans certains cas, les algorithmes sont utilis\u00e9s pour le traitement des donn\u00e9es et les t\u00e2ches de raisonnement automatis\u00e9. Un algorithme est un ensemble sp\u00e9cifique d\u2019instructions con\u00e7ues pour effectuer une t\u00e2che particuli\u00e8re. Cela peut \u00eatre un processus simple, comme la multiplication de deux nombres, ou une op\u00e9ration complexe, comme la lecture d\u2019un fichier vid\u00e9o compress\u00e9. Les moteurs de recherche utilisent des algorithmes complexes pour trier les pages Web pertinentes parmi des millions de r\u00e9sultats. Un algorithme en informatique est une proc\u00e9dure bien d\u00e9finie qui prend certaines valeurs en entr\u00e9e et les traite pour produire une certaine valeur en sortie. Les algorithmes sont essentiels pour l\u2019ex\u00e9cution de proc\u00e9dures \u00e9tape par \u00e9tape pour les calculs et le traitement des donn\u00e9es. Un algorithme est une s\u00e9quence de comportement \u00e9tape par \u00e9tape qui d\u00e9finit un ensemble de calculs. Ils sont utilis\u00e9s pour le calcul, le traitement des donn\u00e9es, le raisonnement automatis\u00e9 et d\u2019autres t\u00e2ches. Veuillez noter qu\u2019un algorithme doit \u00eatre clair et sans ambigu\u00eft\u00e9, il doit avoir des entr\u00e9es et des sorties bien d\u00e9finies, et il doit \u00eatre fini. Lors de la conception d\u2019un algorithme, il y aura g\u00e9n\u00e9ralement des entr\u00e9es donn\u00e9es \u00e0 l\u2019algorithme. Ensuite, apr\u00e8s avoir effectu\u00e9 des calculs en utilisant ces entr\u00e9es, les r\u00e9sultats seront \u00e9mis ou renvoy\u00e9s \u00e0 un utilisateur, ou \u00e0 un autre algorithme qui utilisera ces r\u00e9sultats pour effectuer ses propres calculs \u00e0 \u00eatre sortis ou renvoy\u00e9s. En d\u2019autres termes, les algorithmes pourraient \u00eatre cha\u00een\u00e9s les uns \u00e0 la suite des autres.","title":"Algorithmes : D\u00e9finitions"},{"location":"Algorithmes/01_Premiers_Algorithmes/#notation-sous-forme-de-diagrammes","text":"Pour repr\u00e9senter les algorithmes graphiquement, nous allons utiliser diagrammes d\u2019\u00e9tats UML , en utilisant la notation disponible dans le logiciel PlantUML . Pour repr\u00e9senter les algorithmes de mani\u00e8re graphique, nous utiliserons les Diagrammes d\u2019Activit\u00e9 , et nous utiliserons PlantUML pour les dessiner. Nous repr\u00e9senterons \u00e9galement les algorithmes en pseudocode, dans une notation similaire \u00e0 celle du langage de programmation Python. Plus tard, apr\u00e8s avoir discut\u00e9 des types de donn\u00e9es et de certains autres sujets, nous \u00e9crirons directement les algorithmes dans le langage de programmation Python. Le diagramme suivant montre la notation pour les diagrammes d\u2019activit\u00e9 les plus basiques. Code PlantUML @startuml skinparam defaultFontSize 16 start note right noeud de d\u00e9part end note :some action; note right action simple : lire une valeur, faire un calcul, ... end note :some other action; stop note right noeud de fin end note @enduml","title":"Notation sous forme de diagrammes"},{"location":"Algorithmes/01_Premiers_Algorithmes/#exemples","text":"","title":"Exemples"},{"location":"Algorithmes/01_Premiers_Algorithmes/#calcul-de-laire-dun-rectangle","text":"Commen\u00e7ons par un exemple simple : comment calculons-nous l\u2019aire d\u2019un rectangle ? Nous avons besoin de 2 valeurs pour calculer l\u2019aire d\u2019un rectangle : sa largeur et sa hauteur . Nous supposons pour l\u2019instant que ces 2 valeurs seront entr\u00e9es dans le programme par un utilisateur, \u00e0 l\u2019aide d\u2019un dispositif d\u2019entr\u00e9e (probablement un clavier), et que les r\u00e9sultats seront affich\u00e9s \u00e0 l\u2019utilisateur \u00e0 l\u2019aide d\u2019un dispositif de sortie (probablement un \u00e9cran). Nous verrons plus tard que les entr\u00e9es et les sorties peuvent ne pas \u00eatre prises ou donn\u00e9es directement par/aux utilisateurs, mais pourraient plut\u00f4t \u00eatre donn\u00e9es \u00e0 une fonction en tant que param\u00e8tres, ou renvoy\u00e9es par une fonction. Entr\u00e9es : la largeur et la hauteur du rectangle Sortie : l\u2019 aire du rectangle","title":"Calcul de l&rsquo;aire d&rsquo;un rectangle"},{"location":"Algorithmes/01_Premiers_Algorithmes/#diagramme","text":"Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer largeur; :entrer hauteur; :aire = largeur * hauteur; :afficher aire; stop @enduml","title":"Diagramme"},{"location":"Algorithmes/01_Premiers_Algorithmes/#pseudocode","text":"largeur = entrer() hauteur = entrer() aire = largeur * hauteur afficher(aire)","title":"Pseudocode"},{"location":"Algorithmes/01_Premiers_Algorithmes/#discussion","text":"Certaines actions concernent le calcul de certaines valeurs bas\u00e9es sur d\u2019autres valeurs, comme aire = largeur * hauteur . Notez que nous utilisons * comme symbole de multiplication. Dans ce cas, le calcul largeur * hauteur est \u00e9crit \u00e0 droite du signe \u00e9gal ( = ), et le r\u00e9sultat est conserv\u00e9 dans aire , qui sera affich\u00e9 dans l\u2019\u00e9tape suivante. Dans cet exemple, il y a 3 variables : largeur , hauteur et aire . Ces variables sont utilis\u00e9es pour repr\u00e9senter ou retenir certaines valeurs qui seront entr\u00e9es ou calcul\u00e9es, et qui seront r\u00e9utilis\u00e9es plus tard dans les calculs ou envoy\u00e9es en sortie. Les diagrammes d\u2019activit\u00e9 sont de haut niveau , ce qui signifie qu\u2019ils sont souvent un peu simplifi\u00e9s, ils n\u2019entrent pas dans chaque petit d\u00e9tail. Nous ne nous emb\u00eatons pas \u00e0 d\u00e9finir chaque variable formellement, donc lorsque nous \u00e9crivons entrer largeur , il est sous-entendu qu\u2019une variable nomm\u00e9e largeur sera d\u00e9finie, et sa valeur sera ce qui a \u00e9t\u00e9 entr\u00e9. De m\u00eame, pour afficher aire , nous disons simplement que nous voulons que aire soit affich\u00e9e en sortie, mais nous ne nous emb\u00eatons pas avec les d\u00e9tails d\u2019o\u00f9 et comment aire sera affich\u00e9e. Nous serons un peu plus pr\u00e9cis dans le pseudocode, et beaucoup plus pr\u00e9cis lorsque nous \u00e9crirons un programme pour faire les calculs pour de vrai. \u00c0 ce stade, les diagrammes sont utilis\u00e9s pour avoir une id\u00e9e de ce qui doit \u00eatre fait. Ils deviendront plus compliqu\u00e9s quand nous rencontrerons des algorithmes plus complexes. Avec un peu d\u2019exp\u00e9rience, nous serons en mesure d\u2019\u00e9crire du code directement sans cr\u00e9er d\u2019abord des diagrammes d\u2019activit\u00e9 ou \u00e9crire du pseudocode, mais m\u00eame avec de l\u2019exp\u00e9rience, lorsque nous rencontrons des probl\u00e8mes plus complexes, les diagrammes aident souvent. De nombreux types de diagrammes seront utilis\u00e9s lors de la conception et du d\u00e9veloppement de syst\u00e8mes logiciels, tels que les diagrammes de s\u00e9quences , de cas d\u2019utilisation , d\u2019 \u00e9tats , de classes \u2026 Les entr\u00e9es et les sorties sont elles-m\u00eames des t\u00e2ches complexes, et d\u00e9pendront exactement de la fa\u00e7on dont nous voulons entrer et sortir (afficher) les valeurs. Nous r\u00e9sumons donc ces t\u00e2ches et nous disons simplement pour l\u2019instant que nous entrons et sortons des valeurs d\u2019une certaine mani\u00e8re. Dans le pseudocode, nous \u00e9crivons ces 2 t\u00e2ches un peu diff\u00e9remment par rapport aux diagrammes : nous utilisons la notation de fonction pour \u00eatre un peu plus pr\u00e9cis. La t\u00e2che d\u2019entrer d\u2019une valeur produit (ou donne ou retourne) une valeur, et nous stockons cette valeur dans une variable, comme dans largeur = entrer() . Nous utilisons les parenth\u00e8ses () pour signifier que nous appelons, ou ex\u00e9cutons, la fonction entrer . La valeur produite est stock\u00e9e dans la variable largeur . Nous disons aussi que la valeur renvoy\u00e9e par la fonction entrer est assign\u00e9e \u00e0 la variable largeur . Pour pouvoir accomplir sa t\u00e2che, la fonction afficher a besoin de savoir quelle valeur afficher, donc nous lui donnons une valeur entre les () lorsque nous l\u2019appelons. Dans notre exemple, nous lui avons donn\u00e9 la variable aire , alors elle affiche la valeur contenue dans la variable aire . afficher ne renvoie aucune valeur, c\u2019est pourquoi nous ne l\u2019assignons \u00e0 rien.","title":"Discussion"},{"location":"Algorithmes/01_Premiers_Algorithmes/#meilleures-entrees-et-sorties","text":"Un probl\u00e8me lors de l\u2019entr\u00e9e d\u2019une valeur dans l\u2019exemple pr\u00e9c\u00e9dent est que nous ne donnons aucune information \u00e0 l\u2019utilisateur sur ce qui doit \u00eatre entr\u00e9. Dans ce cas, l\u2019utilisateur devinera probablement que la largeur et la hauteur doivent \u00eatre entr\u00e9es pour pouvoir calculer l\u2019aire d\u2019un rectangle, mais laquelle doit \u00eatre entr\u00e9e en premier ? Dans ce cas, cela n\u2019a pas vraiment d\u2019importance, car nous obtiendrons les m\u00eames r\u00e9sultats, mais en g\u00e9n\u00e9ral, l\u2019inversion de 2 entr\u00e9es peut changer consid\u00e9rablement les r\u00e9sultats. Nous avons donc besoin de donner plus d\u2019informations \u00e0 l\u2019utilisateur. Voici 2 versions faisant la m\u00eame chose.","title":"Meilleures entr\u00e9es et sorties"},{"location":"Algorithmes/01_Premiers_Algorithmes/#diagrammes","text":"Code PlantUML @startuml skinparam defaultFontSize 16 start :afficher \"Calcul de l'aire d'un rectangle\"; :afficher \"Entrez la largeur du rectangle :\"; :entrer largeur; :afficher \"Entrez la hauteur du rectangle :\"; :entrer hauteur; :aire = largeur * hauteur; :afficher \"l'aire est\"; :afficher aire; stop @enduml Code PlantUML @startuml skinparam defaultFontSize 16 start :afficher(\"Calcul de l'aire d'un rectangle\"); :largeur = entrer(\"Entrez la largeur du rectangle :\"); :hauteur = entrer(\"Entrez la hauteur du rectangle :\"); :aire = largeur * hauteur; :afficher(\"l'aire est\", aire); stop @enduml","title":"Diagrammes"},{"location":"Algorithmes/01_Premiers_Algorithmes/#discussion_1","text":"Le premier de ces deux diagrammes est correct, mais il serait g\u00e9n\u00e9ralement consid\u00e9r\u00e9 comme trop verbeux. Nous laisserons de c\u00f4t\u00e9 la sortie suppl\u00e9mentaire pour nous concentrer sur l\u2019algorithme lui-m\u00eame, ou nous utiliserons la deuxi\u00e8me version dans laquelle une nouvelle version de la fonction entrer est utilis\u00e9e directement dans les diagrammes. Cette version de la fonction entrer accepte une cha\u00eene de caract\u00e8res en param\u00e8tre, qui sera affich\u00e9e avant d\u2019attendre qu\u2019une valeur soit entr\u00e9e. Une cha\u00eene de caract\u00e8res, pour la distinguer d\u2019une ou de plusieurs variables, est donn\u00e9e entre guillemets doubles \"\" . La fonction afficher est \u00e9galement utilis\u00e9e diff\u00e9remment. On lui donne 2 choses \u00e0 afficher, une cha\u00eene et une variable contenant les r\u00e9sultats. Elle les affichera l\u2019une apr\u00e8s l\u2019autre. Nous aurons besoin de messages de sortie plus complets lors de l\u2019\u00e9criture du code, et nous les inclurons souvent lors de l\u2019\u00e9criture du pseudocode, mais pas lors de la cr\u00e9ation de diagrammes d\u2019activit\u00e9 pour les garder plus petits et nous aider \u00e0 nous concentrer sur l\u2019algorithme lui-m\u00eame, et non sur les d\u00e9tails des entr\u00e9es et des sorties, \u00e0 moins que l\u2019algorithme devait traiter les entr\u00e9es et les sorties d\u2019une mani\u00e8re tr\u00e8s sp\u00e9cifique.","title":"Discussion"},{"location":"Algorithmes/01_Premiers_Algorithmes/#pseudocode_1","text":"afficher(\"Calcul de l'aire d'un rectangle\") largeur = entrer(\"Entrez la largeur du rectangle :\") hauteur = entrer(\"Entrez la hauteur du rectangle :\") aire = largeur * hauteur afficher(\"l'aire est\", aire)","title":"Pseudocode"},{"location":"Algorithmes/02_Conditionnelles/","text":"Les conditionnelles \u00b6 Prendre des d\u00e9cisions \u00b6 Les algorithmes qui ne font que prendre des entr\u00e9es, calculer des valeurs \u00e0 l\u2019aide de formules et produire des r\u00e9sultats, ne sont pas tr\u00e8s int\u00e9ressants, ou du moins, ils deviendront rapidement redondants. Nous avons besoin d\u2019autres concepts de programmation pour permettre de supporter des algorithmes diff\u00e9rents et plus complexes. Un concept utile est la conditionnelle , utilis\u00e9e pour faire des choix pendant l\u2019ex\u00e9cution d\u2019un algorithme. On l\u2019appelle parfois une branche, car lorsque nous ex\u00e9cutons un algorithme, nous pouvons nous diriger vers l\u2019une des nombreuses branches en fonction de certaines conditions. Pour commencer, nous examinerons des exemples avec seulement 2 cas possibles, avec une condition qui est soit vrai soit faux . Commen\u00e7ons par un exemple pour donner l\u2019id\u00e9e g\u00e9n\u00e9rale avec un algorithme simple. Des exemples plus complexes suivront. Trouver le plus petit de 2 nombres \u00b6 Entr\u00e9es : 2 nombres Sortie : le plus petit nombre des deux Diagrammes \u00b6 Version 1 : condition \u00e0 l\u2019ext\u00e9rieur du losange \u00b6 Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; floating note right le losange est un embranchement (ou une conditionnelle) end note if () then (premier < deuxi\u00e8me ?) :afficher premier; note left si la condition est vraie, faire ceci end note else (sinon) :afficher deuxi\u00e8me; note right sinon, si la condition est fausse, faire ceci end note endif stop @enduml Version 2 : condition \u00e0 l\u2019int\u00e9rieur du losange \u00b6 Le losange est \u201c\u00e9tir\u00e9\u201d horizontalement pour faire de la place \u00e0 la condition, donc le losange n\u2019est d\u00e9sormais plus un losange, il devient un hexagone. Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; floating note right on peut \u00e9galement mettre la condition dans le noeud d'embranchement end note if (premier < deuxi\u00e8me ?) then (oui) :afficher premier; else (non) :afficher deuxi\u00e8me; endif stop @enduml Discussion \u00b6 Seule l\u2019une des deux branches de la conditionnelle sera ex\u00e9cut\u00e9e. Si la condition est vraie, ce qui signifie que le premier nombre est plus petit que l\u2019autre, alors le premier nombre sera affich\u00e9. Si la condition est fausse, alors la seconde branche \u00e0 droite sera ex\u00e9cut\u00e9e, et le deuxi\u00e8me nombre sera affich\u00e9, ce qui signifie que le deuxi\u00e8me nombre n\u2019est pas plus petit que le premier . Mais cela ne signifie pas que le second nombre est plus grand que le premier . Si les deux nombres sont \u00e9gaux, alors la condition est fausse, donc la branche non sera ex\u00e9cut\u00e9e. Les exemples suivants montreront comment traiter l\u2019\u00e9galit\u00e9 entre les deux nombres dans un cas sp\u00e9cifique, donnant ainsi 3 possibilit\u00e9s, ou en d\u2019autres termes, donnant 3 options, ou 3 branches. Notez qu\u2019apr\u00e8s une condition, les deux (ou plus) branches doivent normalement se rejoindre en un losange pour continuer l\u2019algorithme. Dans cet exemple, l\u2019algorithme se termine apr\u00e8s la conditionnelle. Pseudocode \u00b6 premier = entrer() deuxi\u00e8me = entrer() si (premier < deuxi\u00e8me) afficher(premier) else afficher(deuxi\u00e8me) Trouver le plus petit de 2 nombres, version 2 \u00b6 Afficher la r\u00e9ponse sous forme de texte \u00e0 la place de la valeur du plus petit nombre. Entr\u00e9es : 2 nombres Sortie : un message disant que soit le premier nombre ou le deuxi\u00e8me nombre est le plus petit des 2 nombres Diagramme \u00b6 Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; if (premier < deuxi\u00e8me?) then (oui) :afficher \"Le premier nombre est le plus petit\"; else (non) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; endif stop @enduml Discussion \u00b6 Cet exemple n\u2019est pas tout \u00e0 fait correct, car si le deuxi\u00e8me nombre n\u2019est pas plus grand que le premier, cela ne signifie pas automatiquement que le deuxi\u00e8me nombre est le plus petit des 2 : ils pourraient \u00eatre \u00e9gaux. Lors de l\u2019affichage de la valeur du plus petit nombre, cela n\u2019a pas d\u2019importance, nous obtiendrons le bon r\u00e9sultat, mais lors de l\u2019affichage d\u2019un message texte, cela ne sera pas correct dans le cas sp\u00e9cifique o\u00f9 les 2 valeurs sont \u00e9gales. Le prochain exemple utilise une conditionnelle \u00e0 l\u2019int\u00e9rieur d\u2019une autre conditionnelle pour distinguer les 3 cas. Trouver le plus petit de 2 nombres, version 3 \u00b6 Entr\u00e9es : 2 nombres Sortie : un message disant que soit le premier nombre ou le deuxi\u00e8me nombre est le plus petit des 2 nombres, ou un message qui dit que les 2 nombres sont \u00e9gaux Diagramme \u00b6 Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; if () then (premier < deuxi\u00e8me ?) :afficher \"Le premier nombre est le plus petit\"; else (sinon) if () then (premier > deuxi\u00e8me ?) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; else (sinon) :afficher \"Les deux nombres sont \u00e9gaux\"; endif endif stop @enduml Discussion \u00b6 Lorsque nous avons 3 cas (ou branches) ou plus, une seule conditionnelle ne suffira pas, car elle ne distingue que 2 cas, la partie vraie et la partie fausse de la condition. Nous d\u00e9terminons d\u2019abord si le premier nombre est plus petit que le second, puis si oui, nous proc\u00e9dons comme avant. Si le premier nombre n\u2019est pas plus petit que le second, alors nous avons 2 autres cas : le second nombre est plus petit, ou les 2 nombres sont \u00e9gaux. Nous avons donc besoin d\u2019une autre conditionnelle pour distinguer ces 2 cas. Mise en page alternative du diagramme \u00b6 Ce diagramme repr\u00e9sente exactement le m\u00eame algorithme, mais les noeuds sont agenc\u00e9s diff\u00e9remment. Code PlantUML @startuml skinparam defaultFontSize 16 !pragma useVerticalIf on :entrer premier; :entrer deuxi\u00e8me; if (premier < deuxi\u00e8me ?) then (oui) :afficher \"Le premier nombre est le plus petit\"; (non) else if (premier > deuxi\u00e8me ?) then (oui) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; else (non) :afficher \"Les deux nombres sont \u00e9gaux\"; endif stop @enduml Pseudocode \u00b6 Version 1 \u00b6 premier = lire(\"Entrez le premier nombre: \") deuxi\u00e8me = lire(\"Entrez le deuxi\u00e8me nombre: \") si premier < deuxi\u00e8me afficher(premier) sinon afficher(deuxi\u00e8me) fin si Version 2 \u00b6 premier = lire(\"Entrez le premier nombre: \") deuxi\u00e8me = lire(\"Entrez le deuxi\u00e8me nombre: \") si premier < deuxi\u00e8me afficher(\"Le premier nombre est le plus petit\") sinon afficher(\"Le deuxi\u00e8me nombre est le plus petit\") fin si Version 3 \u00b6 premier = lire(\"Entrez le premier nombre: \") deuxi\u00e8me = lire(\"Entrez le deuxi\u00e8me nombre: \") si premier < deuxi\u00e8me afficher(\"Le premier nombre est le plus petit\") sinon si premier > deuxi\u00e8me : afficher(\"Le deuxi\u00e8me nombre est le plus petit\") sinon : afficher(\"Les deux nombres sont \u00e9gaux\") fin si fin si Utiliser un commutateur \u00e0 la place d\u2019une s\u00e9quence de conditions \u00b6 Il est souvent pr\u00e9f\u00e9rable d\u2019utiliser un commutateur (ou switch en anglais) pour remplacer les conditionnelles, surtout lorsqu\u2019il y a beaucoup de cas d\u00e9termin\u00e9s par de nombreuses conditions. Cela rend l\u2019algorithme beaucoup plus facile \u00e0 suivre. Malheureusement, ce ne sont pas tous les langages de programmation qui supportent les commutateurs, et certains langages de programmation ne supportent que certains types sp\u00e9cifiques de commutateurs. L\u2019exemple suivant utilise un commutateur pour remplacer les conditionnelles pour r\u00e9soudre le m\u00eame probl\u00e8me que l\u2019exemple pr\u00e9c\u00e9dent. Il est suivi par un autre exemple avec plus de cas (ou branches), en utilisant un switch d\u2019une mani\u00e8re l\u00e9g\u00e8rement diff\u00e9rente. Le plus petit de 2 nombres avec un switch \u00b6 Diagramme \u00b6 Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; switch (?) case (premier < deuxi\u00e8me ?) :afficher \"Le premier nombre est le plus petit\"; case ( premier > deuxi\u00e8me ?) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; case (premier = deuxi\u00e8me) :afficher \"Les deux nombres sont \u00e9gaux\"; endswitch stop @enduml Discussion \u00b6 Nous avons un seul losange avec un point d\u2019interrogation pour repr\u00e9senter le switch, puis nous avons des fl\u00e8ches \u00e9tiquet\u00e9es avec les diff\u00e9rentes conditions. L\u2019algorithme suivra la fl\u00e8che dont la condition \u00e9value \u00e0 vrai . Il ne devrait y avoir qu\u2019une seule condition qui est vraie \u00e0 tout moment, pour \u00e9viter la confusion quant \u00e0 la fl\u00e8che qui doit \u00eatre suivie. Il peut y avoir un cas sp\u00e9cial suppl\u00e9mentaire \u00e9tiquet\u00e9 d\u00e9faut , qui sera utilis\u00e9 si tous les autres cas sont faux. Dans l\u2019exemple ci-dessus, il n\u2019est pas n\u00e9cessaire d\u2019avoir un cas d\u00e9faut , car nos conditions couvrent tous les cas. Mais ici, on pourrait remplacer le dernier cas qui v\u00e9rifie l\u2019\u00e9galit\u00e9 entre les deux nombres par un cas d\u00e9faut , pour obtenir un r\u00e9sultat \u00e9quivalent. Note : ici, comme nous l\u2019avons fait dans les autres exemples, nous supposons que les valeurs d\u2019entr\u00e9e sont du bon type, dans ce cas des nombres, pour que les algorithmes fonctionnent correctement. En g\u00e9n\u00e9ral, nous devrions nous assurer que les valeurs sont du bon type. Une discussion sur les types de donn\u00e9es et comment valider l\u2019entr\u00e9e fera partie d\u2019un autre chapitre.","title":"Les conditionnelles"},{"location":"Algorithmes/02_Conditionnelles/#les-conditionnelles","text":"","title":"Les conditionnelles"},{"location":"Algorithmes/02_Conditionnelles/#prendre-des-decisions","text":"Les algorithmes qui ne font que prendre des entr\u00e9es, calculer des valeurs \u00e0 l\u2019aide de formules et produire des r\u00e9sultats, ne sont pas tr\u00e8s int\u00e9ressants, ou du moins, ils deviendront rapidement redondants. Nous avons besoin d\u2019autres concepts de programmation pour permettre de supporter des algorithmes diff\u00e9rents et plus complexes. Un concept utile est la conditionnelle , utilis\u00e9e pour faire des choix pendant l\u2019ex\u00e9cution d\u2019un algorithme. On l\u2019appelle parfois une branche, car lorsque nous ex\u00e9cutons un algorithme, nous pouvons nous diriger vers l\u2019une des nombreuses branches en fonction de certaines conditions. Pour commencer, nous examinerons des exemples avec seulement 2 cas possibles, avec une condition qui est soit vrai soit faux . Commen\u00e7ons par un exemple pour donner l\u2019id\u00e9e g\u00e9n\u00e9rale avec un algorithme simple. Des exemples plus complexes suivront.","title":"Prendre des d\u00e9cisions"},{"location":"Algorithmes/02_Conditionnelles/#trouver-le-plus-petit-de-2-nombres","text":"Entr\u00e9es : 2 nombres Sortie : le plus petit nombre des deux","title":"Trouver le plus petit de 2 nombres"},{"location":"Algorithmes/02_Conditionnelles/#diagrammes","text":"","title":"Diagrammes"},{"location":"Algorithmes/02_Conditionnelles/#version-1-condition-a-lexterieur-du-losange","text":"Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; floating note right le losange est un embranchement (ou une conditionnelle) end note if () then (premier < deuxi\u00e8me ?) :afficher premier; note left si la condition est vraie, faire ceci end note else (sinon) :afficher deuxi\u00e8me; note right sinon, si la condition est fausse, faire ceci end note endif stop @enduml","title":"Version 1 : condition \u00e0 l&rsquo;ext\u00e9rieur du losange"},{"location":"Algorithmes/02_Conditionnelles/#version-2-condition-a-linterieur-du-losange","text":"Le losange est \u201c\u00e9tir\u00e9\u201d horizontalement pour faire de la place \u00e0 la condition, donc le losange n\u2019est d\u00e9sormais plus un losange, il devient un hexagone. Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; floating note right on peut \u00e9galement mettre la condition dans le noeud d'embranchement end note if (premier < deuxi\u00e8me ?) then (oui) :afficher premier; else (non) :afficher deuxi\u00e8me; endif stop @enduml","title":"Version 2 : condition \u00e0 l&rsquo;int\u00e9rieur du losange"},{"location":"Algorithmes/02_Conditionnelles/#discussion","text":"Seule l\u2019une des deux branches de la conditionnelle sera ex\u00e9cut\u00e9e. Si la condition est vraie, ce qui signifie que le premier nombre est plus petit que l\u2019autre, alors le premier nombre sera affich\u00e9. Si la condition est fausse, alors la seconde branche \u00e0 droite sera ex\u00e9cut\u00e9e, et le deuxi\u00e8me nombre sera affich\u00e9, ce qui signifie que le deuxi\u00e8me nombre n\u2019est pas plus petit que le premier . Mais cela ne signifie pas que le second nombre est plus grand que le premier . Si les deux nombres sont \u00e9gaux, alors la condition est fausse, donc la branche non sera ex\u00e9cut\u00e9e. Les exemples suivants montreront comment traiter l\u2019\u00e9galit\u00e9 entre les deux nombres dans un cas sp\u00e9cifique, donnant ainsi 3 possibilit\u00e9s, ou en d\u2019autres termes, donnant 3 options, ou 3 branches. Notez qu\u2019apr\u00e8s une condition, les deux (ou plus) branches doivent normalement se rejoindre en un losange pour continuer l\u2019algorithme. Dans cet exemple, l\u2019algorithme se termine apr\u00e8s la conditionnelle.","title":"Discussion"},{"location":"Algorithmes/02_Conditionnelles/#pseudocode","text":"premier = entrer() deuxi\u00e8me = entrer() si (premier < deuxi\u00e8me) afficher(premier) else afficher(deuxi\u00e8me)","title":"Pseudocode"},{"location":"Algorithmes/02_Conditionnelles/#trouver-le-plus-petit-de-2-nombres-version-2","text":"Afficher la r\u00e9ponse sous forme de texte \u00e0 la place de la valeur du plus petit nombre. Entr\u00e9es : 2 nombres Sortie : un message disant que soit le premier nombre ou le deuxi\u00e8me nombre est le plus petit des 2 nombres","title":"Trouver le plus petit de 2 nombres, version 2"},{"location":"Algorithmes/02_Conditionnelles/#diagramme","text":"Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; if (premier < deuxi\u00e8me?) then (oui) :afficher \"Le premier nombre est le plus petit\"; else (non) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; endif stop @enduml","title":"Diagramme"},{"location":"Algorithmes/02_Conditionnelles/#discussion_1","text":"Cet exemple n\u2019est pas tout \u00e0 fait correct, car si le deuxi\u00e8me nombre n\u2019est pas plus grand que le premier, cela ne signifie pas automatiquement que le deuxi\u00e8me nombre est le plus petit des 2 : ils pourraient \u00eatre \u00e9gaux. Lors de l\u2019affichage de la valeur du plus petit nombre, cela n\u2019a pas d\u2019importance, nous obtiendrons le bon r\u00e9sultat, mais lors de l\u2019affichage d\u2019un message texte, cela ne sera pas correct dans le cas sp\u00e9cifique o\u00f9 les 2 valeurs sont \u00e9gales. Le prochain exemple utilise une conditionnelle \u00e0 l\u2019int\u00e9rieur d\u2019une autre conditionnelle pour distinguer les 3 cas.","title":"Discussion"},{"location":"Algorithmes/02_Conditionnelles/#trouver-le-plus-petit-de-2-nombres-version-3","text":"Entr\u00e9es : 2 nombres Sortie : un message disant que soit le premier nombre ou le deuxi\u00e8me nombre est le plus petit des 2 nombres, ou un message qui dit que les 2 nombres sont \u00e9gaux","title":"Trouver le plus petit de 2 nombres, version 3"},{"location":"Algorithmes/02_Conditionnelles/#diagramme_1","text":"Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; if () then (premier < deuxi\u00e8me ?) :afficher \"Le premier nombre est le plus petit\"; else (sinon) if () then (premier > deuxi\u00e8me ?) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; else (sinon) :afficher \"Les deux nombres sont \u00e9gaux\"; endif endif stop @enduml","title":"Diagramme"},{"location":"Algorithmes/02_Conditionnelles/#discussion_2","text":"Lorsque nous avons 3 cas (ou branches) ou plus, une seule conditionnelle ne suffira pas, car elle ne distingue que 2 cas, la partie vraie et la partie fausse de la condition. Nous d\u00e9terminons d\u2019abord si le premier nombre est plus petit que le second, puis si oui, nous proc\u00e9dons comme avant. Si le premier nombre n\u2019est pas plus petit que le second, alors nous avons 2 autres cas : le second nombre est plus petit, ou les 2 nombres sont \u00e9gaux. Nous avons donc besoin d\u2019une autre conditionnelle pour distinguer ces 2 cas.","title":"Discussion"},{"location":"Algorithmes/02_Conditionnelles/#mise-en-page-alternative-du-diagramme","text":"Ce diagramme repr\u00e9sente exactement le m\u00eame algorithme, mais les noeuds sont agenc\u00e9s diff\u00e9remment. Code PlantUML @startuml skinparam defaultFontSize 16 !pragma useVerticalIf on :entrer premier; :entrer deuxi\u00e8me; if (premier < deuxi\u00e8me ?) then (oui) :afficher \"Le premier nombre est le plus petit\"; (non) else if (premier > deuxi\u00e8me ?) then (oui) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; else (non) :afficher \"Les deux nombres sont \u00e9gaux\"; endif stop @enduml","title":"Mise en page alternative du diagramme"},{"location":"Algorithmes/02_Conditionnelles/#pseudocode_1","text":"","title":"Pseudocode"},{"location":"Algorithmes/02_Conditionnelles/#version-1","text":"premier = lire(\"Entrez le premier nombre: \") deuxi\u00e8me = lire(\"Entrez le deuxi\u00e8me nombre: \") si premier < deuxi\u00e8me afficher(premier) sinon afficher(deuxi\u00e8me) fin si","title":"Version 1"},{"location":"Algorithmes/02_Conditionnelles/#version-2","text":"premier = lire(\"Entrez le premier nombre: \") deuxi\u00e8me = lire(\"Entrez le deuxi\u00e8me nombre: \") si premier < deuxi\u00e8me afficher(\"Le premier nombre est le plus petit\") sinon afficher(\"Le deuxi\u00e8me nombre est le plus petit\") fin si","title":"Version 2"},{"location":"Algorithmes/02_Conditionnelles/#version-3","text":"premier = lire(\"Entrez le premier nombre: \") deuxi\u00e8me = lire(\"Entrez le deuxi\u00e8me nombre: \") si premier < deuxi\u00e8me afficher(\"Le premier nombre est le plus petit\") sinon si premier > deuxi\u00e8me : afficher(\"Le deuxi\u00e8me nombre est le plus petit\") sinon : afficher(\"Les deux nombres sont \u00e9gaux\") fin si fin si","title":"Version 3"},{"location":"Algorithmes/02_Conditionnelles/#utiliser-un-commutateur-a-la-place-dune-sequence-de-conditions","text":"Il est souvent pr\u00e9f\u00e9rable d\u2019utiliser un commutateur (ou switch en anglais) pour remplacer les conditionnelles, surtout lorsqu\u2019il y a beaucoup de cas d\u00e9termin\u00e9s par de nombreuses conditions. Cela rend l\u2019algorithme beaucoup plus facile \u00e0 suivre. Malheureusement, ce ne sont pas tous les langages de programmation qui supportent les commutateurs, et certains langages de programmation ne supportent que certains types sp\u00e9cifiques de commutateurs. L\u2019exemple suivant utilise un commutateur pour remplacer les conditionnelles pour r\u00e9soudre le m\u00eame probl\u00e8me que l\u2019exemple pr\u00e9c\u00e9dent. Il est suivi par un autre exemple avec plus de cas (ou branches), en utilisant un switch d\u2019une mani\u00e8re l\u00e9g\u00e8rement diff\u00e9rente.","title":"Utiliser un commutateur \u00e0 la place d&rsquo;une s\u00e9quence de conditions"},{"location":"Algorithmes/02_Conditionnelles/#le-plus-petit-de-2-nombres-avec-un-switch","text":"","title":"Le plus petit de 2 nombres avec un switch"},{"location":"Algorithmes/02_Conditionnelles/#diagramme_2","text":"Code PlantUML @startuml skinparam defaultFontSize 16 start :entrer premier; :entrer deuxi\u00e8me; switch (?) case (premier < deuxi\u00e8me ?) :afficher \"Le premier nombre est le plus petit\"; case ( premier > deuxi\u00e8me ?) :afficher \"Le deuxi\u00e8me nombre est le plus petit\"; case (premier = deuxi\u00e8me) :afficher \"Les deux nombres sont \u00e9gaux\"; endswitch stop @enduml","title":"Diagramme"},{"location":"Algorithmes/02_Conditionnelles/#discussion_3","text":"Nous avons un seul losange avec un point d\u2019interrogation pour repr\u00e9senter le switch, puis nous avons des fl\u00e8ches \u00e9tiquet\u00e9es avec les diff\u00e9rentes conditions. L\u2019algorithme suivra la fl\u00e8che dont la condition \u00e9value \u00e0 vrai . Il ne devrait y avoir qu\u2019une seule condition qui est vraie \u00e0 tout moment, pour \u00e9viter la confusion quant \u00e0 la fl\u00e8che qui doit \u00eatre suivie. Il peut y avoir un cas sp\u00e9cial suppl\u00e9mentaire \u00e9tiquet\u00e9 d\u00e9faut , qui sera utilis\u00e9 si tous les autres cas sont faux. Dans l\u2019exemple ci-dessus, il n\u2019est pas n\u00e9cessaire d\u2019avoir un cas d\u00e9faut , car nos conditions couvrent tous les cas. Mais ici, on pourrait remplacer le dernier cas qui v\u00e9rifie l\u2019\u00e9galit\u00e9 entre les deux nombres par un cas d\u00e9faut , pour obtenir un r\u00e9sultat \u00e9quivalent. Note : ici, comme nous l\u2019avons fait dans les autres exemples, nous supposons que les valeurs d\u2019entr\u00e9e sont du bon type, dans ce cas des nombres, pour que les algorithmes fonctionnent correctement. En g\u00e9n\u00e9ral, nous devrions nous assurer que les valeurs sont du bon type. Une discussion sur les types de donn\u00e9es et comment valider l\u2019entr\u00e9e fera partie d\u2019un autre chapitre.","title":"Discussion"},{"location":"Algorithmes/03_Boucles/","text":"Les boucles \u00b6 Boucles sans compteurs \u00b6 Les boucles sans compteurs sont bas\u00e9es seulement sur une condition, et ne comptent pas le nombre de fois que la boucle est r\u00e9p\u00e9t\u00e9e. Pas opposition, les boucles avec compteurs comptent le nombre de r\u00e9p\u00e9titions de la boucle, et la d\u00e9cision de r\u00e9p\u00e9ter la boucle ou non est bas\u00e9e sur le nombre de r\u00e9p\u00e9titions conserv\u00e9 dans le compteur. Boucle r\u00e9p\u00e9ter ... jusqu'\u00e0 \u00b6 En anglais : repeat ... until . On place une conditionnelle \u00e0 la fin de ce qui doit \u00eatre r\u00e9p\u00e9t\u00e9 (\u00e0 la fin de la boucle). La boucle arr\u00eate quand la condition du jusqu'\u00e0 est vraie, et la boucle continue si la condition est fausse. Donc le retour arri\u00e8re vers le d\u00e9but de la boucle s\u2019effectue quand la condition est fausse. Quand la condition est vraie, on sort de la boucle. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; repeat :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; repeat while (condition ?) is (faux) not (vrai) :faire quelque chose apr\u00e8s la boucle; stop @enduml // faire quelque chose avant la boucle r\u00e9p\u00e9ter // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle jusqu'\u00e0 condition // faire quelque chose apr\u00e8s la boucle Boucle faire ... tant que \u00b6 En anglais : do ... while . On place une conditionnelle \u00e0 la fin de ce qui doit \u00eatre r\u00e9p\u00e9t\u00e9 (\u00e0 la fin de la boucle). La boucle arr\u00eate quand la condition du while est fausse, et la boucle continue si la condition est vraie. Donc le retour arri\u00e8re vers le d\u00e9but de la boucle s\u2019effectue quand la condition est vraie. Quand la condition est fausse, on sort de la boucle. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; repeat :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; repeat while (condition ?) is (vrai) not (faux) :faire quelque chose apr\u00e8s la boucle; stop @enduml // faire quelque chose avant la boucle faire // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle tantque condition // faire quelque chose apr\u00e8s la boucle Boucle tant que \u00b6 En anglais : while . La boucle tant que est diff\u00e9rente des 2 autres parce que la condition est plac\u00e9e au d\u00e9but de la boucle, et par cons\u00e9quent, la condition de boucle est \u00e9valu\u00e9e avant de faire quoi que se soit dans le corps la boucle. Le corps d\u2019une boucle tant que peut ne jamais \u00eatre ex\u00e9cut\u00e9e, mais le corps des boucles faire ... tant que et r\u00e9p\u00e9ter ... jusqu'\u00e0 sont toujours ex\u00e9cut\u00e9s au moins une fois. Mais comme la boucle faire ... tant que , la boucle continue si la condition est vraie et arr\u00eate lorsque la condition est fausse . La diff\u00e9rence est qu\u2019\u00e0 la fin du corps de la boucle, on retournera automatiquement au d\u00e9but pour \u00e9valuer la condition \u00e0 nouveau et alors, on d\u00e9cidera si on continue ou non. Sinon, on doit sauter \u00e0 la premi\u00e8re instruction apr\u00e8s la boucle. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; while (condition ?) is (vrai) :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; endwhile (faux) :faire quelque chose apr\u00e8s la boucle; stop @enduml // faire quelque chose avant la boucle tantque condition : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle fintantque // faire quelque chose apr\u00e8s la boucle Boucles avec compteurs \u00b6 On ajoute une variable, le compteur, qui commence avec la valeur 0 ou 1, et la condition de la boucle est bas\u00e9e sur ce compteur. Le compteur est souvent nomm\u00e9 i ou j ou k \u2026, comme dans la notation math\u00e9matique pour les sommations : \\[\\sum_{i=1}^{n}i^2\\ \\ \\ .\\] On utilise souvent aussi les variables avec des noms plus pr\u00e9cis, comme par exemple nbEssais ( nTries ) ou compteur ( count ). Il n\u2019y a pas de notation sp\u00e9ciale pour ce type de boucle dans les diagrammes, mais en pseudocode et dans la plupart des langages de programmation, il y a diff\u00e9rentes formes de boucles pour ( for ). Dans les diagrammes, on utilise normalement des boucles tant que , et dans le pseudocode et dans les diff\u00e9rents langages de programmation, on peut aussi utiliser les boucles tant que , mais on utilisera normalement les boucles pour lorsque possible. Les boucles pour sont, dans la plupart des langages, une forme compacte des boucles tant que avec compteurs. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; :compteur = 1; :nbR\u00e9p\u00e9titions = 5; while (compteur <= nbR\u00e9p\u00e9titions ?) is (oui) :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; :compteur = compteur + 1; endwhile (non) :faire quelque chose apr\u00e8s la boucle; stop @enduml Dans la plupart des langages de programmation, il existe un op\u00e9rateur sp\u00e9cial pour incr\u00e9menter un entier, ce qui signifie qu\u2019il va ajouter 1 \u00e0 la valeur actuelle d\u2019un nombre entier. \u00c9crire compteur++ est \u00e9quivalent \u00e0 \u00e9crire compteur = compteur + 1 . Il est \u00e9galement possible de commencer avec count = 0 au lieu de commencer avec 1. Pour faire le m\u00eame nombre d\u2019it\u00e9rations \u00e0 travers la boucle, nous devons changer la condition de la boucle pour utiliser < au lieu de <= . PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; :compteur = 0; :nbR\u00e9p\u00e9titions = 5; while (compteur < nbR\u00e9p\u00e9titions ?) is (oui) :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; :compteur++; endwhile (non) :faire quelque chose apr\u00e8s la boucle; stop @enduml Pseudocode avec boucle tant que \u00b6 // faire quelque chose avant la boucle compteur = 1 nbR\u00e9p\u00e9titions = 5 tantque compteur <= nbR\u00e9p\u00e9titions : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle compteur = compteur + 1 fintantque // faire quelque chose apr\u00e8s la boucle // faire quelque chose avant la boucle compteur = 0 nbR\u00e9p\u00e9titions = 5 tantque compteur < nbR\u00e9p\u00e9titions : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle compteur++ fintantque // faire quelque chose apr\u00e8s la boucle Pseudocode avec boucle pour \u00b6 Boucle pour de style Algol \u00b6 // faire quelque chose avant la boucle nbR\u00e9p\u00e9titions = 5 pour compteur de 0 \u00e0 nbR\u00e9p\u00e9titions : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle La valeur de d\u00e9part du compteur est 0. Il va y avoir une r\u00e9p\u00e9tition (ou it\u00e9ration) de la boucle pour chaque valeur de 0 jusqu\u2019\u00e0 nbR\u00e9p\u00e9titions . selon le langage de programmation utilis\u00e9, l\u2019intervalle de valeurs peut \u00eatre inclusif ou exclusif par rapport \u00e0 la limite sup\u00e9rieure : si inclusif , alors le nombre d\u2019it\u00e9rations dans la boucle donn\u00e9e plus haut sera 6 parce qu\u2019il y aura une it\u00e9ration pour toutes les valeurs enti\u00e8res de 0 \u00e0 5 inclusivement dans ce cas, il serait probablement pr\u00e9f\u00e9rable d\u2019initialiser le compteur \u00e0 1 au lieu de 0. si exclusif , alors le nombre d\u2019it\u00e9rations dans la boucle donn\u00e9e plus haut sera 5 parce que la boucle s\u2019arr\u00eatera lorsque compteur == 5 , donc il aura seulement des it\u00e9rations pour les valeurs de compteur de 0, 1, 2, 3, et 4. La limite inf\u00e9rieure (la valeur de d\u00e9part) est toujours inclusive. Nous utiliserons la convention que l\u2019intervalle est exclusif , comme dans le langage de programmation Python . Boucle pour de style C \u00b6 // faire quelque chose avant la boucle nbR\u00e9p\u00e9titions = 5 pour (compteur = 0; compteur < nbR\u00e9p\u00e9titions; compteur++) : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle compteur = 0 : s\u2019ex\u00e9cute une seule fois, juste avant l\u2019\u00e9valuation de la condition de la boucle compteur < nbR\u00e9p\u00e9titions : la condition s\u2019ex\u00e9cute \u00e0 r\u00e9p\u00e9tition (ou pour chaque it\u00e9ration) de la boucle, avant le corps de la boucle comme pour une boucle tant que , si la condition est vraie, alors le corps de la boucle est ex\u00e9cut\u00e9e sinon (si la condition est fausse), alors la boucle est termin\u00e9e et l\u2019ex\u00e9cution continue avec les instructions suivant la boucle nbR\u00e9p\u00e9titions++ : mise \u00e0 jour du compteur, qui s\u2019ex\u00e9cute \u00e0 la fin du corps de la boucle, juste avant de revenir au d\u00e9but de la boucle pour r\u00e9\u00e9valuer la condition Boucles pour chaque \u00b6 En anglais : for each . Les boucles pour chaque sont diff\u00e9rentes des autres boucles parce qu\u2019elles n\u00e9cessitent normalement l\u2019utilisation de collections de valeurs ou d\u2019objets, et d\u2019it\u00e9rateurs. Les collections, comme les tableaux et les listes, contiennent plusieurs valeurs ou objets, et les it\u00e9rateurs permettent de parcourir toutes les valeurs ou objets d\u2019une collection sous forme de s\u00e9quence. Les collections, les it\u00e9rateurs et les boucles pour chaque seront pr\u00e9sent\u00e9s de fa\u00e7on plus d\u00e9taill\u00e9e plus tard. Pour l\u2019instant, seulement une id\u00e9e g\u00e9n\u00e9rale du concept est pr\u00e9sent\u00e9e. Il est difficile de bien repr\u00e9senter les boucles pour chaque dans des diagrammes, donc les exemples seront uniquement sous forme de pseudocode. Boucle pour chaque avec intervalle \u00b6 // faire quelque chose avant la boucle nbR\u00e9p\u00e9titions = 5 pour chaque i dans intervalle(0, nbR\u00e9p\u00e9titions) : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle La fonction intervalle(0, nbR\u00e9p\u00e9titions) va cr\u00e9er une liste de nombres entiers dans l\u2019intervalle [0, nbR\u00e9p\u00e9titions) : les crochets [ et ] veulent dire inclusif les parenth\u00e8ses ( et ) veulent dire exclusif donc les nombres dans la liste vont \u00eatre 0, 1, 2, 3 et 4. \u00c0 la premi\u00e8re it\u00e9ration, i va \u00eatre 0 \u00c0 la deuxi\u00e8me it\u00e9ration, i va \u00eatre 1 \u00c0 la troisi\u00e8me it\u00e9ration, i va \u00eatre 2 \u00c0 la quatri\u00e8me it\u00e9ration, i va \u00eatre 3 \u00c0 la cinqui\u00e8me et derni\u00e8re it\u00e9ration, i va \u00eatre 4 Boucle pour chaque avec liste ou tableau \u00b6 // faire quelque chose avant la boucle nombres = [5, 1, 8, 3] pour chaque i dans nombres : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle \u00c0 la premi\u00e8re it\u00e9ration, i va \u00eatre 5 \u00c0 la deuxi\u00e8me it\u00e9ration, i va \u00eatre 1 \u00c0 la troisi\u00e8me it\u00e9ration, i va \u00eatre 8 \u00c0 la quatri\u00e8me et derni\u00e8re it\u00e9ration, i va \u00eatre 3","title":"Les boucles"},{"location":"Algorithmes/03_Boucles/#les-boucles","text":"","title":"Les boucles"},{"location":"Algorithmes/03_Boucles/#boucles-sans-compteurs","text":"Les boucles sans compteurs sont bas\u00e9es seulement sur une condition, et ne comptent pas le nombre de fois que la boucle est r\u00e9p\u00e9t\u00e9e. Pas opposition, les boucles avec compteurs comptent le nombre de r\u00e9p\u00e9titions de la boucle, et la d\u00e9cision de r\u00e9p\u00e9ter la boucle ou non est bas\u00e9e sur le nombre de r\u00e9p\u00e9titions conserv\u00e9 dans le compteur.","title":"Boucles sans compteurs"},{"location":"Algorithmes/03_Boucles/#boucle-repeter-jusqua","text":"En anglais : repeat ... until . On place une conditionnelle \u00e0 la fin de ce qui doit \u00eatre r\u00e9p\u00e9t\u00e9 (\u00e0 la fin de la boucle). La boucle arr\u00eate quand la condition du jusqu'\u00e0 est vraie, et la boucle continue si la condition est fausse. Donc le retour arri\u00e8re vers le d\u00e9but de la boucle s\u2019effectue quand la condition est fausse. Quand la condition est vraie, on sort de la boucle. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; repeat :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; repeat while (condition ?) is (faux) not (vrai) :faire quelque chose apr\u00e8s la boucle; stop @enduml // faire quelque chose avant la boucle r\u00e9p\u00e9ter // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle jusqu'\u00e0 condition // faire quelque chose apr\u00e8s la boucle","title":"Boucle r\u00e9p\u00e9ter ... jusqu'\u00e0"},{"location":"Algorithmes/03_Boucles/#boucle-faire-tant-que","text":"En anglais : do ... while . On place une conditionnelle \u00e0 la fin de ce qui doit \u00eatre r\u00e9p\u00e9t\u00e9 (\u00e0 la fin de la boucle). La boucle arr\u00eate quand la condition du while est fausse, et la boucle continue si la condition est vraie. Donc le retour arri\u00e8re vers le d\u00e9but de la boucle s\u2019effectue quand la condition est vraie. Quand la condition est fausse, on sort de la boucle. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; repeat :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; repeat while (condition ?) is (vrai) not (faux) :faire quelque chose apr\u00e8s la boucle; stop @enduml // faire quelque chose avant la boucle faire // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle tantque condition // faire quelque chose apr\u00e8s la boucle","title":"Boucle faire ... tant que"},{"location":"Algorithmes/03_Boucles/#boucle-tant-que","text":"En anglais : while . La boucle tant que est diff\u00e9rente des 2 autres parce que la condition est plac\u00e9e au d\u00e9but de la boucle, et par cons\u00e9quent, la condition de boucle est \u00e9valu\u00e9e avant de faire quoi que se soit dans le corps la boucle. Le corps d\u2019une boucle tant que peut ne jamais \u00eatre ex\u00e9cut\u00e9e, mais le corps des boucles faire ... tant que et r\u00e9p\u00e9ter ... jusqu'\u00e0 sont toujours ex\u00e9cut\u00e9s au moins une fois. Mais comme la boucle faire ... tant que , la boucle continue si la condition est vraie et arr\u00eate lorsque la condition est fausse . La diff\u00e9rence est qu\u2019\u00e0 la fin du corps de la boucle, on retournera automatiquement au d\u00e9but pour \u00e9valuer la condition \u00e0 nouveau et alors, on d\u00e9cidera si on continue ou non. Sinon, on doit sauter \u00e0 la premi\u00e8re instruction apr\u00e8s la boucle. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; while (condition ?) is (vrai) :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; endwhile (faux) :faire quelque chose apr\u00e8s la boucle; stop @enduml // faire quelque chose avant la boucle tantque condition : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle fintantque // faire quelque chose apr\u00e8s la boucle","title":"Boucle tant que"},{"location":"Algorithmes/03_Boucles/#boucles-avec-compteurs","text":"On ajoute une variable, le compteur, qui commence avec la valeur 0 ou 1, et la condition de la boucle est bas\u00e9e sur ce compteur. Le compteur est souvent nomm\u00e9 i ou j ou k \u2026, comme dans la notation math\u00e9matique pour les sommations : \\[\\sum_{i=1}^{n}i^2\\ \\ \\ .\\] On utilise souvent aussi les variables avec des noms plus pr\u00e9cis, comme par exemple nbEssais ( nTries ) ou compteur ( count ). Il n\u2019y a pas de notation sp\u00e9ciale pour ce type de boucle dans les diagrammes, mais en pseudocode et dans la plupart des langages de programmation, il y a diff\u00e9rentes formes de boucles pour ( for ). Dans les diagrammes, on utilise normalement des boucles tant que , et dans le pseudocode et dans les diff\u00e9rents langages de programmation, on peut aussi utiliser les boucles tant que , mais on utilisera normalement les boucles pour lorsque possible. Les boucles pour sont, dans la plupart des langages, une forme compacte des boucles tant que avec compteurs. PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; :compteur = 1; :nbR\u00e9p\u00e9titions = 5; while (compteur <= nbR\u00e9p\u00e9titions ?) is (oui) :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; :compteur = compteur + 1; endwhile (non) :faire quelque chose apr\u00e8s la boucle; stop @enduml Dans la plupart des langages de programmation, il existe un op\u00e9rateur sp\u00e9cial pour incr\u00e9menter un entier, ce qui signifie qu\u2019il va ajouter 1 \u00e0 la valeur actuelle d\u2019un nombre entier. \u00c9crire compteur++ est \u00e9quivalent \u00e0 \u00e9crire compteur = compteur + 1 . Il est \u00e9galement possible de commencer avec count = 0 au lieu de commencer avec 1. Pour faire le m\u00eame nombre d\u2019it\u00e9rations \u00e0 travers la boucle, nous devons changer la condition de la boucle pour utiliser < au lieu de <= . PlantUML code @startuml skinparam defaultFontSize 16 start :faire quelque chose avant la boucle; :compteur = 0; :nbR\u00e9p\u00e9titions = 5; while (compteur < nbR\u00e9p\u00e9titions ?) is (oui) :faire quelque chose \u00e0 l'int\u00e9rieur de la boucle; :compteur++; endwhile (non) :faire quelque chose apr\u00e8s la boucle; stop @enduml","title":"Boucles avec compteurs"},{"location":"Algorithmes/03_Boucles/#pseudocode-avec-boucle-tant-que","text":"// faire quelque chose avant la boucle compteur = 1 nbR\u00e9p\u00e9titions = 5 tantque compteur <= nbR\u00e9p\u00e9titions : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle compteur = compteur + 1 fintantque // faire quelque chose apr\u00e8s la boucle // faire quelque chose avant la boucle compteur = 0 nbR\u00e9p\u00e9titions = 5 tantque compteur < nbR\u00e9p\u00e9titions : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle compteur++ fintantque // faire quelque chose apr\u00e8s la boucle","title":"Pseudocode avec boucle tant que"},{"location":"Algorithmes/03_Boucles/#pseudocode-avec-boucle-pour","text":"","title":"Pseudocode avec boucle pour"},{"location":"Algorithmes/03_Boucles/#boucle-pour-de-style-algol","text":"// faire quelque chose avant la boucle nbR\u00e9p\u00e9titions = 5 pour compteur de 0 \u00e0 nbR\u00e9p\u00e9titions : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle La valeur de d\u00e9part du compteur est 0. Il va y avoir une r\u00e9p\u00e9tition (ou it\u00e9ration) de la boucle pour chaque valeur de 0 jusqu\u2019\u00e0 nbR\u00e9p\u00e9titions . selon le langage de programmation utilis\u00e9, l\u2019intervalle de valeurs peut \u00eatre inclusif ou exclusif par rapport \u00e0 la limite sup\u00e9rieure : si inclusif , alors le nombre d\u2019it\u00e9rations dans la boucle donn\u00e9e plus haut sera 6 parce qu\u2019il y aura une it\u00e9ration pour toutes les valeurs enti\u00e8res de 0 \u00e0 5 inclusivement dans ce cas, il serait probablement pr\u00e9f\u00e9rable d\u2019initialiser le compteur \u00e0 1 au lieu de 0. si exclusif , alors le nombre d\u2019it\u00e9rations dans la boucle donn\u00e9e plus haut sera 5 parce que la boucle s\u2019arr\u00eatera lorsque compteur == 5 , donc il aura seulement des it\u00e9rations pour les valeurs de compteur de 0, 1, 2, 3, et 4. La limite inf\u00e9rieure (la valeur de d\u00e9part) est toujours inclusive. Nous utiliserons la convention que l\u2019intervalle est exclusif , comme dans le langage de programmation Python .","title":"Boucle pour de style Algol"},{"location":"Algorithmes/03_Boucles/#boucle-pour-de-style-c","text":"// faire quelque chose avant la boucle nbR\u00e9p\u00e9titions = 5 pour (compteur = 0; compteur < nbR\u00e9p\u00e9titions; compteur++) : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle compteur = 0 : s\u2019ex\u00e9cute une seule fois, juste avant l\u2019\u00e9valuation de la condition de la boucle compteur < nbR\u00e9p\u00e9titions : la condition s\u2019ex\u00e9cute \u00e0 r\u00e9p\u00e9tition (ou pour chaque it\u00e9ration) de la boucle, avant le corps de la boucle comme pour une boucle tant que , si la condition est vraie, alors le corps de la boucle est ex\u00e9cut\u00e9e sinon (si la condition est fausse), alors la boucle est termin\u00e9e et l\u2019ex\u00e9cution continue avec les instructions suivant la boucle nbR\u00e9p\u00e9titions++ : mise \u00e0 jour du compteur, qui s\u2019ex\u00e9cute \u00e0 la fin du corps de la boucle, juste avant de revenir au d\u00e9but de la boucle pour r\u00e9\u00e9valuer la condition","title":"Boucle pour de style C"},{"location":"Algorithmes/03_Boucles/#boucles-pour-chaque","text":"En anglais : for each . Les boucles pour chaque sont diff\u00e9rentes des autres boucles parce qu\u2019elles n\u00e9cessitent normalement l\u2019utilisation de collections de valeurs ou d\u2019objets, et d\u2019it\u00e9rateurs. Les collections, comme les tableaux et les listes, contiennent plusieurs valeurs ou objets, et les it\u00e9rateurs permettent de parcourir toutes les valeurs ou objets d\u2019une collection sous forme de s\u00e9quence. Les collections, les it\u00e9rateurs et les boucles pour chaque seront pr\u00e9sent\u00e9s de fa\u00e7on plus d\u00e9taill\u00e9e plus tard. Pour l\u2019instant, seulement une id\u00e9e g\u00e9n\u00e9rale du concept est pr\u00e9sent\u00e9e. Il est difficile de bien repr\u00e9senter les boucles pour chaque dans des diagrammes, donc les exemples seront uniquement sous forme de pseudocode.","title":"Boucles pour chaque"},{"location":"Algorithmes/03_Boucles/#boucle-pour-chaque-avec-intervalle","text":"// faire quelque chose avant la boucle nbR\u00e9p\u00e9titions = 5 pour chaque i dans intervalle(0, nbR\u00e9p\u00e9titions) : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle La fonction intervalle(0, nbR\u00e9p\u00e9titions) va cr\u00e9er une liste de nombres entiers dans l\u2019intervalle [0, nbR\u00e9p\u00e9titions) : les crochets [ et ] veulent dire inclusif les parenth\u00e8ses ( et ) veulent dire exclusif donc les nombres dans la liste vont \u00eatre 0, 1, 2, 3 et 4. \u00c0 la premi\u00e8re it\u00e9ration, i va \u00eatre 0 \u00c0 la deuxi\u00e8me it\u00e9ration, i va \u00eatre 1 \u00c0 la troisi\u00e8me it\u00e9ration, i va \u00eatre 2 \u00c0 la quatri\u00e8me it\u00e9ration, i va \u00eatre 3 \u00c0 la cinqui\u00e8me et derni\u00e8re it\u00e9ration, i va \u00eatre 4","title":"Boucle pour chaque avec intervalle"},{"location":"Algorithmes/03_Boucles/#boucle-pour-chaque-avec-liste-ou-tableau","text":"// faire quelque chose avant la boucle nombres = [5, 1, 8, 3] pour chaque i dans nombres : // faire quelque chose \u00e0 l'int\u00e9rieur de la boucle finpour // faire quelque chose apr\u00e8s la boucle \u00c0 la premi\u00e8re it\u00e9ration, i va \u00eatre 5 \u00c0 la deuxi\u00e8me it\u00e9ration, i va \u00eatre 1 \u00c0 la troisi\u00e8me it\u00e9ration, i va \u00eatre 8 \u00c0 la quatri\u00e8me et derni\u00e8re it\u00e9ration, i va \u00eatre 3","title":"Boucle pour chaque avec liste ou tableau"}]}